# Test complex scenario with multiple remote dependencies and fetch-all

# Create a workflow that has multiple remote dependencies  
exec sh -c 'echo "schema-version: v1" > complex-workflow.yaml'
exec sh -c 'echo "tasks:" >> complex-workflow.yaml'
exec sh -c 'echo "  complex:" >> complex-workflow.yaml'
exec sh -c 'echo "    steps:" >> complex-workflow.yaml'
exec sh -c 'echo "      - run: echo \"Starting complex workflow\"" >> complex-workflow.yaml'
exec sh -c 'echo "      - uses: ${HTTP_BASE_URL}/simple.yaml?task=hello" >> complex-workflow.yaml'
exec sh -c 'echo "      - uses: ${HTTP_BASE_URL}/with-uses.yaml?task=main" >> complex-workflow.yaml'
exec sh -c 'echo "      - run: echo \"Complex workflow complete\"" >> complex-workflow.yaml'

# Test fetch-all prefetches all nested dependencies
exec maru2 --fetch-all --from file:complex-workflow.yaml
! stderr .
! stdout .

# Test execution after fetch-all
exec maru2 --from file:complex-workflow.yaml complex
stdout 'Starting complex workflow'
stdout 'Hello from remote!'
stdout 'Starting main task'
stdout 'Hello from remote!'
stdout 'Complex workflow complete'

# Test fetch-all with always policy to refresh cache
exec maru2 --fetch-policy always --fetch-all --from file:complex-workflow.yaml complex
stdout 'Starting complex workflow'
stdout 'Hello from remote!'
stdout 'Starting main task'
stdout 'Hello from remote!'
stdout 'Complex workflow complete'

# Test that cache was used efficiently (no additional stderr for cache hits)
exec maru2 --fetch-policy if-not-present --from file:complex-workflow.yaml complex
stdout 'Starting complex workflow'
stdout 'Hello from remote!'

-- tasks.yaml --
schema-version: v1
tasks:
  local:
    steps:
      - run: echo "Local task"
